<html>

<head>
    <style>
        /* body {
            background: url(data:image/jpeg;base64,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);
            background-size: contain;
        } */

        html,
        body {
            padding: 0px;
            margin: 0px;
        }

        canvas {
            /* filter: blur(3px) contrast(81.5) contrast(99) contrast(99) contrast(99) contrast(99) contrast(99) contrast(99); */
            /* background: transparent !important; */
            /* width: 100vw; */
            /* height: 90vh; */

            margin: 0px;
            left: 0px;
            top: 0px;
        }
    </style>
</head>

<body>


    <script src="matter.js"></script>

    <script>

        // module aliases
        var Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            Composite = Matter.Composite,
            Constraint = Matter.Constraint,
            MouseConstraint = Matter.MouseConstraint,
            Mouse = Matter.Mouse,
            World = Matter.World;

        // create an engine
        var engine = Engine.create();

        // create a renderer
        var render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight * 0.8,
                wireframes: false, // <-- important
                // showAngleIndicator: true,
            }
        });

        // create two boxes and a ground
        // let bodies = []
        // let constr = []
        let diameter = 4;
        let maxNumberOfConnectionsPerBody = 20
        const maxDistanceToAttach = diameter * 10

        // let num = 0
        // let lengthOfConstraint = diameter * 10
        // let standardParticleOptions = {
        //     restitution: 0,
        //     friction: 1,
        //     render: {
        //         fillStyle: 'red',
        //         lineWidth: 0
        //     }
        // }
        // for (let i = 0; i < num; i++) {
        //     bodies.push(Bodies.circle(5 * (i % 10) + 200, (i % 10) * 5 + 20, diameter, standardParticleOptions))

        // }



        // const constraintInterface = {

        //     pointA: { x: 0, y: 0 },
        //     pointB: { x: 0, y: 0 },
        //     length: lengthOfConstraint,
        //     angularStiffness: 1,
        //     stiffness: 1,
        //     damping: 0,
        //     render: {
        //         visible: true,
        //         anchors: false,
        //         lineWidth: 1,
        //     }
        // }

        // for (let i = 1; i < num; i++) {




        //     if (bodies[i - 1]) {
        //         constr.push(Constraint.create({
        //             ...constraintInterface,
        //             bodyA: bodies[i],
        //             bodyB: bodies[i - 1]
        //         }))
        //     }

        //     if (bodies[i - 2]) {
        //         constr.push(Constraint.create({
        //             ...constraintInterface,
        //             bodyA: bodies[i - 1],
        //             bodyB: bodies[i - 2]
        //         }))

        //         constr.push(Constraint.create({
        //             ...constraintInterface,
        //             bodyA: bodies[i],
        //             bodyB: bodies[i - 2]
        //         }))

        //     }


        //     if (bodies[i - 3]) {
        //         constr.push(Constraint.create({
        //             ...constraintInterface,
        //             bodyA: bodies[i - 2],
        //             bodyB: bodies[i - 3]
        //         }))
        //         constr.push(Constraint.create({
        //             ...constraintInterface,
        //             bodyA: bodies[i - 3],
        //             bodyB: bodies[i - 1]
        //         }))
        //         constr.push(Constraint.create({
        //             ...constraintInterface,
        //             bodyA: bodies[i],
        //             bodyB: bodies[i - 3]
        //         }))
        //     }







        // }

        // var boxA = Bodies.circle(400, 200, 1);
        // var boxB = Bodies.rectangle(450, 50, 80, 80);


        var ground = Bodies.rectangle(0, 810, 3000, 200, {
            restitution: 0,
            friction: 0.5,
            slop: 0,
            label: "ground",
            render: {
                fillStyle: 'red',
                lineWidth: 0
            },
            isStatic: true, render: { fillStyle: 'black' }
        });

        // add all of the bodies to the world
        World.add(engine.world, [ground]);



        var mouse = Mouse.create(render.canvas)
        var mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                // length: 100,
                stiffness: 0.5,
                damping: 0,
                render: {
                    anchors: true,
                    visible: true
                }
            }
        });

        engine.world.gravity.y = 0;

        World.add(engine.world, mouseConstraint);
        // World.add(engine.world, constr);



        // keep the mouse in sync with rendering
        render.mouse = mouse;

        // run the renderer
        Render.run(render);

        // create runner
        var runner = Runner.create();

        // run the engine
        Runner.run(runner, engine);



        function findOutIfThereIsAlreadyAConstraintWithTheseTwoBodies(b1, b2) {



            let which = engine.world.constraints.filter(k => {
                return ((k.bodyA || {}).id == b1.id &&
                    (k.bodyB || {}).id == b2.id) ||
                    ((k.bodyB || {}).id == b1.id &&
                        (k.bodyA || {}).id == b2.id)
            })
            if (which.length > 0) return which[0]
        }


        //COLLITION DETECTION


        function collisionHandbler(e) {
            for (let p of e.pairs) {
                // console.log(p)
                // debugger
                // console.log(p.bodyA, p.bodyB)

                // if (p.bodyA.id != "ground") p.bodyA.isSensor = true
                // if (p.bodyB.id != "ground") p.bodyB.isSensor = true




                let maxConnectionsPerParticle = 3

                if (p.bodyA.id == "ground" || p.bodyB.id == "ground") continue
                if (findOutIfThereIsAlreadyAConstraintWithTheseTwoBodies(p.bodyA, p.bodyB)) continue
                if ((p.bodyA.constraints || []).length > 6 || (p.bodyB.constraints || []).length >= maxConnectionsPerParticle) continue

                else console.log("Agregando constraint entre", p.bodyA, p.bodyB)
                let newConstraint = Constraint.create({
                    pointA: { x: 0, y: 0 },
                    pointB: { x: 0, y: 0 },
                    length: diameter,
                    angularStiffness: 0.9,
                    // isSensor: false,
                    // isSleeping: true,
                    stiffness: 0.9,
                    damping: 0.01,
                    render: {
                        visible: true,
                        anchors: false,
                        strokeStyle: getRandomBrownishColor(0, 0.12),
                        lineWidth: diameter * 3,
                    },
                    bodyA: p.bodyA,
                    bodyB: p.bodyB,

                })

                if (!Array.isArray(p.bodyA.constraints)) p.bodyA.constraints = []
                p.bodyA.constraints.push(newConstraint)

                if (!Array.isArray(p.bodyB.constraints)) p.bodyB.constraints = []
                p.bodyB.constraints.push(newConstraint)


                World.add(engine.world, [newConstraint]);

            }

        }



        // Matter.Events.on(engine, "collisionActive", (e) => { collisionHandbler(e) })




        function dist(x1, y1, x2, y2) {
            var a = x1 - x2;
            var b = y1 - y2;
            return Math.sqrt(a * a + b * b);
        }

        function findTwoClosestParticles(x, y) {
            let arr = []
            for (let i = 0; i < engine.world.bodies.length; i++) {
                let b = engine.world.bodies[i]
                if (b.label == "ground") continue
                let distance = dist(x, y, b.position.x, b.position.y)
                arr.push({ body: b, distance: distance })
            }

            let newArr = arr.sort((a, b) => a.distance > b.distance ? 1 : -1)
            return newArr
        }



        function addAutomaticConnections(arr) {
            // console.log("#add automatic", numberOfAutomaticConnections, arr)
            // if (numberOfAutomaticConnections == undefined) numberOfAutomaticConnections = 3

            let howManyConnectionsWeMadeNow = 0

            arr = arr ? arr : engine.world.bodies
            for (let i = 0; i < arr.length; i++) {
                //EACH BODY
                let b = arr[i]
                if (b.label == "ground") continue
                let closestP = findTwoClosestParticles(b.position.x, b.position.y)

                closestP = (closestP || []).filter(k => k.distance < maxDistanceToAttach)

                //GET THE CLOSEST BODIES                
                for (let i = 0; i < closestP.length; i++) {
                    // if (counterOfConstraints >= numberOfAutomaticConnections) break
                    let closeParticle = closestP[i]




                    if (!closeParticle) continue
                    if (closeParticle.body == b) continue
                    if (closeParticle.distance == 0) continue
                    if (findOutIfThereIsAlreadyAConstraintWithTheseTwoBodies(closeParticle.body, b)) continue
                    //CHECK HOW MANY CONSTRAINTS IT ALREADY HAS
                    //I KEEP TRACK OF THIS MYSELF IN EACH BODY
                    if ((b.constraints || []).length >= maxNumberOfConnectionsPerBody || (closeParticle.constraints || []).length >= maxNumberOfConnectionsPerBody) {
                        break
                    }

                    // alert(1)


                    let newConstraint = Constraint.create({
                        pointA: { x: 0, y: 0 },
                        pointB: { x: 0, y: 0 },
                        // length: diameter * 2,
                        angularStiffness: 0.9,
                        stiffness: 0.9,
                        damping: 0.01,
                        render: {
                            visible: true,
                            anchors: false,
                            strokeStyle: getRandomBrownishColor(0.1, 0.22),
                            lineWidth: diameter * 3,
                        },
                        bodyA: closeParticle.body,
                        bodyB: b,

                    })
                    //ADD CONSTRAINT TO THE WORLD
                    World.add(engine.world, [newConstraint]);

                    //ADD CONSTRAINT TO BOTH BODIES, TO KEEP TRACK OF THEM
                    if (!Array.isArray(b.constraints)) b.constraints = []
                    b.constraints.push(newConstraint)

                    if (!Array.isArray(closeParticle.body.constraints)) closeParticle.body.constraints = []
                    closeParticle.body.constraints.push(newConstraint)

                    howManyConnectionsWeMadeNow++


                }//for




            }//for

            console.log("#we added ", howManyConnectionsWeMadeNow, "new constraints")
        }


        function removeParticle(x, y) {


            let closeP = findTwoClosestParticles(x, y)
            if (!closeP[0]) return

            if (dist(x, y, closeP[0].body.position.x, closeP[0].body.position.y) < diameter * 3) {
                for (let constr of closeP[0].body.constraints) {
                    World.remove(engine.world, constr);

                }
                World.remove(engine.world, closeP[0].body);
            }

        }

        function getRandomBrownishColor(minA, maxA) {
            let r = Math.floor(150 + Math.random() * 45)
            let g = Math.floor(20 + Math.random() * 40)
            let b = Math.floor(Math.random() * 50)

            if (minA == undefined) minA = 0
            if (maxA == undefined) maxA = 1

            let a = (minA + (maxA - minA) * Math.random()).toFixed(2)
            return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
        }

        function addParticles(x, y) {
            let arrOfBodies = []



            let bodyOptions = {
                restitution: 0.1,
                // mass: 9999,
                friction: 0.5,
                slop: -diameter * 0.35,
                // isSensor: true,
                render: {
                    fillStyle: getRandomBrownishColor(0.66, 1),
                    lineWidth: diameter * 2,
                    strokeStyle: getRandomBrownishColor(0.3, 0.7)

                },
                // density: 99999999999999
                // mass: 0
            }
            let numOfParticlesToAdd = 1

            for (let i = 0; i < numOfParticlesToAdd; i++) {
                let newX = x + (i % 3) * diameter / 2
                let newY = y + Math.floor(i / 3) * diameter / 2
                arrOfBodies.push(Bodies.circle(newX, newY, diameter, bodyOptions))
            }



            World.add(engine.world, arrOfBodies);


            // addAutomaticConnections( arrOfBodies)
        }

        function indicateWhichParticleItIs(x, y) {
            let closeP = findTwoClosestParticles(x, y)
            if (!closeP[0]) return

            if (dist(x, y, closeP[0].body.position.x, closeP[0].body.position.y) < diameter * 2) {
                let p = closeP[0].body
                window.tempParticle = p
                console.log(p)
            }
        }

        function removeIsSensorFromAllParticles() {
            for (let p of engine.world.bodies) {
                p.isSensor = false
            }
        }

        function addClickListenerToCanvas() {
            let canvas = document.querySelector("canvas")
            canvas.onmouseleave = e => window.isDown = false
            canvas.onmousedown = e => {
                window.isDown = e.which
                let box = canvas.getBoundingClientRect()
                let x = e.x - box.x
                let y = e.y - box.y
                if (e.which == 1) indicateWhichParticleItIs(x, y)
                else if (e.which == 3) addParticles(x, y)



            }
            canvas.onmouseup = e => {
                window.isDown = false
            }
            canvas.onmousemove = e => {
                if (!window.isDown) return
                let box = canvas.getBoundingClientRect()
                let x = e.x - box.x
                let y = e.y - box.y

                if (window.isDown == 2) {
                    //REMOVE PARTICLES


                    removeParticle(x, y)

                    return
                } else if (window.isDown == 3) {
                    //ADD PARTICLES


                    addParticles(x, y)


                }

            }
        }
        addClickListenerToCanvas()


    </script>
    <br>
    <button onclick="    engine.world.gravity.y = 1">turn gravity on</button>
    <br>
    <button onclick="    engine.world.gravity.y = 0">turn gravity off</button>
    <button onclick=" addAutomaticConnections();">add connections</button>

    <button onclick=" removeIsSensorFromAllParticles();">remove isSensor</button>

</body>

</html>